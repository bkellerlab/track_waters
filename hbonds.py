import numpy as np
import re


def map_w_to_index(t, t_red, idx_file, atom_mapping, verbose=False):
    '''
    Map water name to index in each frame of reduced trajectory.

    This function maps the indices of water residues in a reduced trajectory to
    water letter codes corresponding to water oxygen atom indices of the whole
    trajectory, mapped by track_s1_water. This applies to water reduced
    trajectories generated by the dynamic search of remove_far_waters and
    tracked s1 pocket water with track_s1_water.

    Parameters
    ----------
    t : md.Trajectory
        Whole trajectory on which track_s1_water was run
    t_red : md.Trajectory
        Reduced trajectory generated by dynamic search of remove_far_waters.
    idx_file : str
        Path to water indices file generated by remove_far_waters.
    atom_mapping : dict
        Mapping of water atom indices to water letter codes as generated by
        track_s1_water. The keys need to be the water letter codes and values
        numpy arrays of shape (n_frames,) that hold the water oxygen atom
        indices for each frame.
    verbose : bool
        Verbose mode.
    '''
    # water residue indices in reduced and whole/actual trajectory
    wrid_red = [r.index for r in t_red.top.residues if r.is_water]
    wrid_whole = np.loadtxt(idx_file).astype('int')

    # enforce integer type on mapping
    atom_mapping = atom_mapping.astype('int')

    # list of letter codes from mapping
    letter_codes = [x for x in atom_mapping.keys()]

    # assign water residue indices of whole trj to letter codes
    wrid_letters = {}
    for wl in letter_codes:
        wrid_letters[wl] = np.array([t.top.atom(x).residue.index for x in atom_mapping[wl]])

    # map water residue indices of reduced trj to letter codes
    mapping_res = {}
    for wl in letter_codes:
        mapping_res[wl] = np.zeros(t.n_frames, dtype=int)
        for i_frame in range(t.n_frames):
            wrid = wrid_letters[wl][i_frame]
            if wrid in wrid_whole[i_frame]:
                res_idx, = np.where(wrid_whole[i_frame] == wrid)
                if len(res_idx) == 1:
                    res_idx = res_idx[0]
                else:
                    raise ValueError(f'More than one index {wrid} in frame {i_frame}.')

                mapping_res[wl][i_frame] = wrid_red[res_idx]

            else:
                mapping_res[wl][i_frame] = 0

    return mapping_res


def convert_hb_atom(idx,
                    t,
                    sidechain_ids=None,
                    water_ids=None,
                    wlet_mapping=None,
                    i_frame=None):
    '''
    Convert atom index to hbond string.

    The hbond string indicates the residue of donor and acceptor and wether the
    sidechain or backbone of the residue will be involved.

    Parameters
    ----------
    idx : int
        Atom index of hydrogen bond donor or acceptor.
    t : md.Trajectory
        Trajectory in which the atom index can be found.
    sidechain_ids : np.ndarray or None
        Atom indices of sidechain atoms in trajectory. If None, will be selected
        from t.
    water_ids : np.ndarray or None
        Atom indices of water atoms in trajectory. If None, will be selected
        from t.
    wlet_mapping : dict or None
        Mapping of water residue indices to letter codes.
    i_frame : int or None
        Number of current frame. Needed when wlet mapping is enabled.

    Returns
    -------
    s : str
        Hbond string.
    '''
    # already converted
    if type(idx) == str:
        return idx

    # load water and sidechain atom indices
    if not type(sidechain_ids) == np.ndarray:
        sidechain_ids = t.top.select('is_sidechain')
    if not type(water_ids) == np.ndarray:
        water_ids = t.top.select('is_water')

    a = t.top.atom(idx)
    if idx in water_ids:
        if wlet_mapping:
            s = a.residue.name + str(a.residue.resSeq) + 'w' + f'-{a.element.symbol}'
            for wl in wlet_mapping:
                w_id = wlet_mapping[wl].astype('int')[i_frame]
                if w_id == a.residue.index and w_id != 0:
                    s = wl
        else:
            s = a.residue.name + str(a.residue.resSeq) + 'w' + f'-{a.element.symbol}'
    elif idx in sidechain_ids:
        s = a.residue.name + str(a.residue.resSeq) + 's' + f'-{a.element.symbol}'
    else:
        s = a.residue.name + str(a.residue.resSeq) + 'b' + f'-{a.element.symbol}'
    return s


def hbond_to_string(hbonds,
                    t,
                    wlet_mapping=None):
    '''
    Convert atom indices from mdtraj hbond output to strings indicating residue and sidechain/backbone. Deletes H-Atom.

    Parameters
    ----------
    hbonds : list of np.ndarray
        Output from md.wernet_nilsson().
    t : md.Trajectory
        Trajectory from which the hbonds were computed.

    Returns
    -------
    hbonds_new : list of np.ndarray
        Hbonds with hbond strings instead of atom indices.
    '''
    hbonds_new = []

    # load sidechain and water atom indices
    sidechain_ids = t.top.select('is_sidechain')
    water_ids = t.top.select('is_water')

    for i_frame, frame in enumerate(hbonds):
        if not wlet_mapping:
            donors = np.array([convert_hb_atom(x, t, sidechain_ids, water_ids) for x in frame.T[0]])
            acceptors = np.array([convert_hb_atom(x, t, sidechain_ids, water_ids)
                                  for x in frame.T[2]])
        else:
            donors = np.array([convert_hb_atom(x, t, sidechain_ids, water_ids,
                                               wlet_mapping, i_frame) for x in frame.T[0]])
            acceptors = np.array([convert_hb_atom(x, t, sidechain_ids, water_ids,
                                                  wlet_mapping, i_frame) for x in frame.T[2]])

        frame_new = np.dstack((donors, acceptors))[0]
        hbonds_new.append(frame_new)

    return hbonds_new


def hbond_matrix(hbond_trjs):
    '''
    Extract hbond frequency matrix from list of donor-acceptor arrays for each frame.

    Parameters
    ----------
    hbond_trjs : list
        Contains lists of np.ndarray for each trj for the hydrogen bonds in each
        frame.

    Returns
    -------
    hbond_matrix : np.ndarray
        2D Array of shape (donors,acceptors) with frequency for each hbond.
    donors : list
        Donors cooresponding to indices in H-bond matrix.
    acceptors : list
        Acceptors corresponding to indices in H-bond matrix.

    '''
    # total number of frames
    n_frames_tot = 0

    # total possible donors/acceptors
    donors = []
    acceptors = []

    for hbonds in hbond_trjs:
        # add frames of trjs to total number of frames
        n_frames_tot += len(hbonds)

        # add to list of possible donors and acceptors
        for frame in hbonds:
            don_frame = frame[:, 0]
            acc_frame = frame[:, 1]
            for do in don_frame:
                if do not in donors:
                    donors.append(do)
            for ac in acc_frame:
                if ac not in acceptors:
                    acceptors.append(ac)

    # sort donors/acceptors so mutual atoms are sorted before non mutual donors/acceptors
    donors_sorted = []
    acceptors_sorted = []
    for do in donors:
        if do in acceptors:
            donors_sorted.append(do)
            acceptors_sorted.append(do)

    donors_sorted = sorted(donors_sorted, key=lambda x: _resseq_finder(x))
    acceptors_sorted = sorted(acceptors_sorted, key=lambda x: _resseq_finder(x))

    for do in donors:
        if do not in donors_sorted:
            donors_sorted.append(do)
    for ac in acceptors:
        if ac not in acceptors_sorted:
            acceptors_sorted.append(ac)

    donors = donors_sorted
    acceptors = acceptors_sorted

    # initialize hbond matrix
    hbond_matrix = np.zeros((len(donors), len(acceptors)))

    # set values of hbnod matrix
    for hbonds in hbond_trjs:
        for frame in hbonds:
            for hb in frame:
                i_donor = donors.index(hb[0])
                i_acceptor = acceptors.index(hb[1])

                hbond_matrix[i_donor, i_acceptor] += 1

    # normalize
    hbond_matrix = hbond_matrix / n_frames_tot

    return (hbond_matrix, donors, acceptors)


def _resseq_finder(s):
    '''Get resSeq from donor/acceptor string.'''
    p = re.search(r'[0-9]+', s)
    if p:
        return int(p[0])
    else:
        # hbond string does not include resseq, i.e. letter code
        # return unicode from string + 10000
        return ord(s) + 10000
